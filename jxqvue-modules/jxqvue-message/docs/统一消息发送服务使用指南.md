# 统一消息发送服务使用指南

## 概述

`UnifiedMessageService` 是一个统一的消息发送服务，为所有模块提供标准化的消息发送接口。避免了每个模块都创建自己的消息服务类，实现了代码复用和维护简化。

## 核心优势

1. **统一接口**: 所有模块使用相同的消息发送接口
2. **模板化**: 支持基于模板的消息发送
3. **可扩展**: 易于添加新的消息类型
4. **维护简单**: 集中管理消息发送逻辑
5. **避免循环依赖**: 通过Map传递数据，避免模块间循环依赖

## 服务接口

### 1. 通用模板消息发送

```java
/**
 * 根据模板编码发送消息
 * 
 * @param templateCode 模板编码
 * @param variables 模板变量
 * @param receiverUserIds 接收用户ID列表
 * @return 发送结果
 */
public boolean sendMessageByTemplate(String templateCode, Map<String, Object> variables, List<Long> receiverUserIds)
```

### 2. 业务专用消息发送

```java
// 生产订单下达通知
public boolean sendProductionOrderReleaseNotification(Map<String, Object> orderData, List<Long> receiverUserIds)

// BOM审批通知
public boolean sendBomApprovalNotification(Map<String, Object> bomData, List<Long> receiverUserIds)

// 库存预警通知
public boolean sendInventoryAlertNotification(Map<String, Object> inventoryData, List<Long> receiverUserIds)
```

### 3. 自定义消息发送

```java
/**
 * 发送自定义消息
 * 
 * @param title 消息标题
 * @param content 消息内容
 * @param messageType 消息类型
 * @param messageLevel 消息级别
 * @param receiverUserIds 接收用户ID列表
 * @return 发送结果
 */
public boolean sendCustomMessage(String title, String content, String messageType, String messageLevel, List<Long> receiverUserIds)
```

## 使用示例

### 1. 生产订单模块使用示例

```java
@Service
public class ErpProductionOrderServiceImpl implements IErpProductionOrderService {
    
    @Autowired
    private UnifiedMessageService unifiedMessageService;
    
    @Override
    @Transactional
    public int updateErpProductionOrderStatus(ErpProductionOrder erpProductionOrder) {
        erpProductionOrder.setUpdateTime(DateUtils.getNowDate());
        int result = erpProductionOrderMapper.updateErpProductionOrderStatus(erpProductionOrder);
        
        // 如果状态更新为"下达"，发送消息通知
        if (result > 0 && "2".equals(erpProductionOrder.getStatus())) {
            try {
                // 准备订单数据
                Map<String, Object> orderData = new HashMap<>();
                orderData.put("orderCode", erpProductionOrder.getOrderCode());
                orderData.put("orderName", erpProductionOrder.getOrderName());
                orderData.put("productName", erpProductionOrder.getProductName());
                orderData.put("plannedQuantity", erpProductionOrder.getPlannedQuantity());
                orderData.put("unitName", erpProductionOrder.getUnitName());
                orderData.put("plannedStartDate", erpProductionOrder.getPlannedStartDate());
                orderData.put("plannedEndDate", erpProductionOrder.getPlannedEndDate());
                orderData.put("priority", erpProductionOrder.getPriority());
                
                // 获取相关用户ID列表
                List<Long> relatedUserIds = getRelatedUserIds(erpProductionOrder);
                if (!relatedUserIds.isEmpty()) {
                    // 发送生产订单下达通知
                    unifiedMessageService.sendProductionOrderReleaseNotification(orderData, relatedUserIds);
                }
            } catch (Exception e) {
                System.err.println("发送生产订单下达通知失败: " + e.getMessage());
            }
        }
        
        return result;
    }
}
```

### 2. BOM管理模块使用示例

```java
@Service
public class ErpBomServiceImpl implements IErpBomService {
    
    @Autowired
    private UnifiedMessageService unifiedMessageService;
    
    @Override
    @Transactional
    public AjaxResult approveBom(Long bomId, boolean forceApprove) {
        // ... 审批逻辑 ...
        
        // 审批成功后发送通知
        if (result > 0) {
            try {
                // 准备BOM数据
                Map<String, Object> bomData = new HashMap<>();
                bomData.put("bomCode", currentBom.getBomCode());
                bomData.put("bomName", currentBom.getBomName());
                bomData.put("productName", currentBom.getProductName());
                bomData.put("version", currentBom.getVersion());
                bomData.put("approvalStatus", "已审批");
                
                // 获取相关用户ID列表
                List<Long> relatedUserIds = getRelatedUserIds(currentBom);
                if (!relatedUserIds.isEmpty()) {
                    // 发送BOM审批通知
                    unifiedMessageService.sendBomApprovalNotification(bomData, relatedUserIds);
                }
            } catch (Exception e) {
                System.err.println("发送BOM审批通知失败: " + e.getMessage());
            }
        }
        
        return AjaxResult.success("BOM审批成功");
    }
}
```

### 3. 库存管理模块使用示例

```java
@Service
public class ErpInventoryServiceImpl implements IErpInventoryService {
    
    @Autowired
    private UnifiedMessageService unifiedMessageService;
    
    public void checkInventoryAlert() {
        // 检查库存预警
        List<ErpInventory> alertItems = getInventoryAlertItems();
        
        for (ErpInventory item : alertItems) {
            try {
                // 准备库存数据
                Map<String, Object> inventoryData = new HashMap<>();
                inventoryData.put("materialCode", item.getMaterialCode());
                inventoryData.put("materialName", item.getMaterialName());
                inventoryData.put("currentQuantity", item.getCurrentQuantity());
                inventoryData.put("minQuantity", item.getMinQuantity());
                inventoryData.put("alertType", "库存不足");
                
                // 获取相关用户ID列表
                List<Long> relatedUserIds = getInventoryAlertUserIds();
                if (!relatedUserIds.isEmpty()) {
                    // 发送库存预警通知
                    unifiedMessageService.sendInventoryAlertNotification(inventoryData, relatedUserIds);
                }
            } catch (Exception e) {
                System.err.println("发送库存预警通知失败: " + e.getMessage());
            }
        }
    }
}
```

### 4. 自定义消息发送示例

```java
@Service
public class CustomBusinessService {
    
    @Autowired
    private UnifiedMessageService unifiedMessageService;
    
    public void sendCustomNotification() {
        // 发送自定义消息
        String title = "系统维护通知";
        String content = "系统将于今晚22:00-24:00进行维护，请提前保存数据。";
        String messageType = "1"; // 系统消息
        String messageLevel = "2"; // 重要级别
        
        List<Long> userIds = Arrays.asList(1L, 2L, 3L); // 所有用户
        
        boolean success = unifiedMessageService.sendCustomMessage(
            title, content, messageType, messageLevel, userIds
        );
        
        if (success) {
            System.out.println("自定义消息发送成功");
        }
    }
}
```

## 消息模板配置

### 1. 创建消息模板

```sql
-- 创建消息模板
INSERT INTO message_template (
    template_name, template_code, template_type, category_id, category_name,
    title_template, content_template, message_type, message_level, variables, status,
    create_by, create_time, remark
) VALUES (
    '生产订单下达通知', 'PRODUCTION_ORDER_RELEASE', 'PRODUCTION_ORDER',
    (SELECT category_id FROM message_template_category WHERE category_code = 'PRODUCTION'),
    '生产管理',
    '生产订单下达通知 - {orderCode}',
    '您好！\n\n生产订单 {orderCode} 已下达，请准备开始工作。\n\n订单详情：\n- 订单名称：{orderName}\n- 产品名称：{productName}\n- 计划数量：{plannedQuantity} {unitName}\n- 计划开始时间：{plannedStartDate}\n- 计划完成时间：{plannedEndDate}\n- 优先级：{priority}\n\n请及时查看订单详情并开始生产准备工作。\n\n如有疑问，请联系相关负责人。\n\n系统自动发送',
    '2', '2', '{"orderCode":"订单编码","orderName":"订单名称","productName":"产品名称","plannedQuantity":"计划数量","unitName":"单位名称","plannedStartDate":"计划开始时间","plannedEndDate":"计划完成时间","priority":"优先级"}',
    '0', 'admin', NOW(), '生产订单状态变更为"下达"时自动发送的通知消息模板'
);
```

### 2. 模板变量定义

```sql
-- 创建模板变量
INSERT INTO message_template_variable (
    template_id, variable_name, variable_code, variable_type, is_required, default_value, description, sort_order, create_by, create_time
) VALUES 
(
    (SELECT template_id FROM message_template WHERE template_code = 'PRODUCTION_ORDER_RELEASE'),
    '订单编码', 'orderCode', 'STRING', 1, '', '生产订单编码', 1, 'admin', NOW()
),
(
    (SELECT template_id FROM message_template WHERE template_code = 'PRODUCTION_ORDER_RELEASE'),
    '订单名称', 'orderName', 'STRING', 1, '', '生产订单名称', 2, 'admin', NOW()
);
```

## 扩展新的消息类型

### 1. 添加新的业务消息方法

在`UnifiedMessageService`中添加新的方法：

```java
/**
 * 发送质量检验通知
 * 
 * @param qualityData 质量检验数据
 * @param receiverUserIds 接收用户ID列表
 * @return 发送结果
 */
public boolean sendQualityInspectionNotification(Map<String, Object> qualityData, List<Long> receiverUserIds) {
    // 准备模板变量
    Map<String, Object> variables = prepareQualityVariables(qualityData);
    
    // 调用通用发送方法
    return sendMessageByTemplate("QUALITY_INSPECTION_NOTIFICATION", variables, receiverUserIds);
}

/**
 * 准备质量检验模板变量
 * 
 * @param qualityData 质量检验数据
 * @return 变量映射
 */
private Map<String, Object> prepareQualityVariables(Map<String, Object> qualityData) {
    Map<String, Object> variables = new HashMap<>();
    
    variables.put("inspectionCode", StringUtils.isNotEmpty((String)qualityData.get("inspectionCode")) ? (String)qualityData.get("inspectionCode") : "");
    variables.put("productName", StringUtils.isNotEmpty((String)qualityData.get("productName")) ? (String)qualityData.get("productName") : "");
    variables.put("inspectionResult", StringUtils.isNotEmpty((String)qualityData.get("inspectionResult")) ? (String)qualityData.get("inspectionResult") : "");
    variables.put("inspectionDate", qualityData.get("inspectionDate") != null ? DateUtils.parseDateToStr("yyyy-MM-dd HH:mm", (java.util.Date)qualityData.get("inspectionDate")) : "");
    
    return variables;
}
```

### 2. 创建对应的消息模板

```sql
-- 创建质量检验通知模板
INSERT INTO message_template (
    template_name, template_code, template_type, category_id, category_name,
    title_template, content_template, message_type, message_level, variables, status,
    create_by, create_time, remark
) VALUES (
    '质量检验通知', 'QUALITY_INSPECTION_NOTIFICATION', 'QUALITY_INSPECTION',
    (SELECT category_id FROM message_template_category WHERE category_code = 'QUALITY'),
    '质量管理',
    '质量检验通知 - {inspectionCode}',
    '您好！\n\n质量检验 {inspectionCode} 已完成。\n\n检验详情：\n- 产品名称：{productName}\n- 检验结果：{inspectionResult}\n- 检验时间：{inspectionDate}\n\n请及时查看检验结果。\n\n系统自动发送',
    '2', '2', '{"inspectionCode":"检验编码","productName":"产品名称","inspectionResult":"检验结果","inspectionDate":"检验时间"}',
    '0', 'admin', NOW(), '质量检验完成时自动发送的通知消息模板'
);
```

## 最佳实践

### 1. 错误处理
- 消息发送失败不应影响主业务流程
- 使用try-catch包装消息发送逻辑
- 记录详细的错误日志

### 2. 性能考虑
- 避免在事务中执行耗时的消息发送操作
- 考虑使用异步消息发送
- 批量发送消息时注意性能

### 3. 数据传递
- 使用Map传递数据，避免循环依赖
- 确保传递的数据类型正确
- 处理null值和空字符串

### 4. 用户获取
- 实现合理的用户获取逻辑
- 避免发送给不相关的用户
- 考虑用户权限和角色

### 5. 模板管理
- 定期检查和更新消息模板
- 使用有意义的模板编码
- 提供详细的变量说明

## 总结

`UnifiedMessageService` 提供了一个统一、灵活、可扩展的消息发送解决方案。通过模板化和标准化的接口，各个模块可以轻松集成消息发送功能，同时保持代码的简洁和可维护性。

这种设计模式的优势：
1. **统一性**: 所有模块使用相同的消息发送接口
2. **可维护性**: 集中管理消息发送逻辑
3. **可扩展性**: 易于添加新的消息类型
4. **解耦性**: 避免模块间的循环依赖
5. **复用性**: 减少重复代码
